/*********************************************************************
 *
 * Copyright (C) 2021, Northwestern University
 * See COPYRIGHT notice in top-level directory.
 *
 * This program is part of the E3SM I/O benchmark.
 *
 *********************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <mpi.h>
#include <e3sm_io.h>
#include <e3sm_io_err.h>
#include <stdio.h>
#include <stdlib.h>

struct off_len {
	int off;
	int len;
};

/*----< compare() >---------------------------------------------------------*/
/* This subroutine is used in qsort() */
static int compare (const void *p1, const void *p2) {
	int i = ((struct off_len *)p1)->off;
	int j = ((struct off_len *)p2)->off;
	if (i > j) return (1);
	if (i < j) return (-1);
	return 0;
}

/*----< read_io_decomp() >-------------------------------------------------*/
/* Read I/O decomposition file, cfg->decomp_path. The contents of the file
 * are shown below, an example from 866x72_16p.nc
 *
 *   % ncdump -h f_case_866x72_16p.nc
 *   netcdf f_case_866x72_16p.nc {
 *   // file format: CDF-1
 *   dimensions:
 *       num_decomp = 3 ;
 *       decomp_nprocs = 16 ;
 *       D1.total_nreqs = 47 ;
 *       D2.total_nreqs = 407 ;
 *       D3.total_nreqs = 29788 ;
 *   variables:
 *       int D1.nreqs(decomp_nprocs) ;
 *           D1.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D1.offsets(D1.total_nreqs) ;
 *           D1.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D1.lengths(D1.total_nreqs) ;
 *           D1.lengths:description = "Lengths of noncontiguous requests" ;
 *           D1.lengths:max = 36 ;
 *           D1.lengths:min = 9 ;
 *       int D2.nreqs(decomp_nprocs) ;
 *           D2.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D2.offsets(D2.total_nreqs) ;
 *           D2.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D2.lengths(D2.total_nreqs) ;
 *           D2.lengths:description = "Lengths of noncontiguous requests" ;
 *           D2.lengths:max = 4 ;
 *           D2.lengths:min = 1 ;
 *       int D3.nreqs(decomp_nprocs) ;
 *           D3.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D3.offsets(D3.total_nreqs) ;
 *           D3.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D3.lengths(D3.total_nreqs) ;
 *           D3.lengths:description = "Lengths of noncontiguous requests" ;
 *           D3.lengths:max = 4 ;
 *           D3.lengths:min = 1 ;
 *
 *   // global attributes:
 *       :command_line = "./dat2nc -o f_case_866x72_16p.nc -1
 * datasets/piodecomp16tasks16io01dims_ioid_514.dat -2
 * datasets/piodecomp16tasks16io01dims_ioid_516.dat -3
 * datasets/piodecomp16tasks16io02dims_ioid_548.dat " ; :D1.ndims = 1 ; :D1.dims = 866 ;
 *       :D1.max_nreqs = 4 ;
 *       :D1.min_nreqs = 2 ;
 *       :D2.ndims = 1 ;
 *       :D2.dims = 866 ;
 *       :D2.max_nreqs = 39 ;
 *       :D2.min_nreqs = 13 ;
 *       :D3.ndims = 2 ;
 *       :D3.dims = 72 , 866 ;
 *       :D3.max_nreqs = 2808 ;
 *       :D3.min_nreqs = 936 ;
 *   }
 *
 * Arguments:
 *   cfg->decomp_path: (IN) input file name, a NetCDF file containing the data
 *                     decomposition generated by PIO library from an E3SM run.
 *   decom->num_decomp (OUT) number of decompositions
 *   decom->ndims:     (OUT) number of decomposition dimensions
 *   decom->dims:      (OUT) global array dimension lengths of decompositions
 *   decom->contig_nreqs: (OUT) number of noncontiguous requests assigned to
 *                     this process. May be zero.
 *   decom->disps:     (OUT) starting offsets of individual requests (sorted)
 *                     Memory space will be allocated in this subroutine
 *                     and must be freed by the caller. Any pair of
 *                     disps[][i] and blocklens[][i] is within the size of
 *                     the least significant dimension.
 *   decom->blocklens: (OUT) lengths of individual requests
 *                     Memory space will be allocated in this subroutine
 *                     and must be freed by the caller.
 */

int read_decomp_nc4 (e3sm_io_config *cfg, e3sm_io_decom *decom) {
	char name[128];
	int err, rank, nprocs, ncid, varid, proc_start, proc_count;
	int i, j, k, nreqs, *all_nreqs, *all_raw_nreqs, dimids[3], id;
	int has_raw_decom;
	size_t num, decomp_nprocs, total_nreqs, start, count;
	MPI_Info info = MPI_INFO_NULL;
	struct off_len *myreqs;

	/* set MPI-IO hints: decomposition variables are usually small and enabling
	 * collective buffering read can be expensive. Doing independent reads is
	 * often much faster. An example is when using Lustre on Cori at NERSC.
	 */
	MPI_Info_create (&info);
	MPI_Info_set (info, "romio_cb_read", "disable");
	MPI_Info_set (info, "romio_no_indep_rw", "false");

	MPI_Comm_rank (cfg->io_comm, &rank);
	MPI_Comm_size (cfg->io_comm, &nprocs);

	decom->num_decomp = 0;

	/* open input file that contains I/O decomposition information */
	err = nc_open (cfg->decomp_path, NC_NOWRITE, &ncid);
	if (err != NC_NOERR) {
		printf ("Error in %s line %d function %s:\n", __FILE__, __LINE__, __func__);
		printf ("\tnc_open() file %s\n", cfg->decomp_path);
		printf ("\t(%d) %s\n", err, nc_strerror (err));
		goto err_out;
	}

	MPI_Info_free (&info);

	/* number of decompositions stored in file */
	err = nc_inq_dimid (ncid, "num_decomp", &dimids[0]);
	CHECK_ERR
	err = nc_inq_dimlen (ncid, dimids[0], &num);
	CHECK_ERR
	decom->num_decomp = (int)num;

	/* number of processes used when the decomposition was produced */
	err = nc_inq_dimid (ncid, "decomp_nprocs", &dimids[0]);
	CHECK_ERR
	err = nc_inq_dimlen (ncid, dimids[0], &decomp_nprocs);
	CHECK_ERR

	/* decomp_nprocs is the number of processes used to generate the E3SM data
	 * decomposition. nprocs is the number of processes running this benchmark.
	 * This benchmark allows nprocs to be different from decomp_nprocs. When
	 * nprocs is less than decomp_nprocs, some of nprocs processes will carry
	 * out the requests for other decomp_nprocs processes. The requests
	 * responsible by this process starts from proc_start with the number
	 * proc_count. When nprocs is bigger than decomp_nprocs, then processes
	 * with rank ID >= decomp_nprocs will have no write request and MUST
	 * participate the collective I/O subroutines.
	 */
	proc_count = decomp_nprocs / nprocs;
	proc_start = rank * proc_count;
	if (rank < decomp_nprocs % nprocs) {
		proc_start += rank;
		proc_count++;
	} else
		proc_start += decomp_nprocs % nprocs;
	/* proc_count is the number of decomposition processes this process is
	 * responsible to carry out their requests. proc_start is the starting
	 * rank ID of the decomposition process.
	 */

	/* id: D1, D2, ... D6, indicates different decompositions */
	for (id = 0; id < decom->num_decomp; id++) {
		decom->contig_nreqs[id] = 0;
		decom->disps[id]		= NULL;
		decom->blocklens[id]	= NULL;
		decom->raw_offsets[id]	= NULL;

		/* total number of noncontiguous requests of all processes */
		sprintf (name, "D%d.total_nreqs", id + 1);
		err = nc_inq_dimid (ncid, name, &dimids[1]);
		CHECK_ERR
		err = nc_inq_dimlen (ncid, dimids[1], &total_nreqs);
		CHECK_ERR

		/* ndims: number of decomposition dimensions, not variable dimensions
		 * In E3SM, decomposition is along the lowest dimensions of 2D, 3D,
		 * or 4D variables.
		 */
		sprintf (name, "D%d.dims", id + 1);
		/* obtain the number of dimensions of this decomposition */
		err = nc_inq_attlen (ncid, NC_GLOBAL, name, &num);
		CHECK_ERR
		decom->ndims[id] = (int)num;
		/* obtain the dimension lengths of this decomposition */
		err = nc_get_att_longlong (ncid, NC_GLOBAL, name, decom->dims[id]);
		CHECK_ERR

		/* obtain varid of request variable Dx.nreqs */
		sprintf (name, "D%d.nreqs", id + 1);
		err = nc_inq_varid (ncid, name, &varid);
		CHECK_ERR

		/* read all numbers of requests */
		all_nreqs = (int *)malloc (decomp_nprocs * sizeof (int));
		err		  = nc_get_var_int (ncid, varid, all_nreqs);
		CHECK_ERR

		/* calculate start index in Dx.offsets for this process */
		i	  = 0;
		start = 0;
		for (start = 0, i = 0; i < proc_start; i++) start += all_nreqs[i];

		/* calculate number of requests for this process */
		count = 0;
		for (; i < proc_start + proc_count; i++) count += all_nreqs[i];
		nreqs = count;
		free (all_nreqs);

		if (cfg->verbose)
			printf ("D%d rank %d: proc_start=%d proc_count=%d start%zd count=%zd\n", id + 1, rank,
					proc_start, proc_count, start, count);

		/* read starting offsets of requests into disps[] */
		decom->disps[id] = (int *)malloc (nreqs * sizeof (int));
		sprintf (name, "D%d.offsets", id + 1);
		err = nc_inq_varid (ncid, name, &varid);
		CHECK_ERR
		err = nc_get_vara_int (ncid, varid, &start, &count, decom->disps[id]);
		CHECK_ERR

		/* read lengths of requests into blocklens[] */
		decom->blocklens[id] = (int *)malloc (nreqs * sizeof (int));
		sprintf (name, "D%d.lengths", id + 1);
		err = nc_inq_varid (ncid, name, &varid);
		CHECK_ERR
		err = nc_get_vara_int (ncid, varid, &start, &count, decom->blocklens[id]);
		CHECK_ERR

		/* sort all disps[] of all responsible requests into an increasing
		 * order (this is to satisfy the MPI fileview or monotonically
		 * nondecreasing file offset requirement)
		 */
		myreqs = (struct off_len *)malloc (nreqs * sizeof (struct off_len));
		for (i = 0; i < nreqs; i++) {
			myreqs[i].off = decom->disps[id][i];
			myreqs[i].len = decom->blocklens[id][i];
		}
		qsort ((void *)myreqs, nreqs, sizeof (struct off_len), compare);
		for (i = 0; i < nreqs; i++) {
			decom->disps[id][i]		= myreqs[i].off;
			decom->blocklens[id][i] = myreqs[i].len;
		}
		free (myreqs);

		/* coalesce offset-length pairs */
		j = 0;
		for (i = 1; i < nreqs; i++) {
			if (decom->disps[id][i] % decom->dims[id][decom->ndims[id] - 1] == 0 ||
				decom->disps[id][i] > decom->disps[id][j] + decom->blocklens[id][j]) {
				/* break contiguity at dimension boundaries or noncontiguous */
				j++;
				if (j < i) {
					decom->disps[id][j]		= decom->disps[id][i];
					decom->blocklens[id][j] = decom->blocklens[id][i];
				}
			} else
				decom->blocklens[id][j] += decom->blocklens[id][i];
		}
		/* update number of true noncontiguous requests */
		if (nreqs > 0) decom->contig_nreqs[id] = j + 1;

		/* ADIOS blob I/O requires the decomposition map in the original form,
		 * i.e. all offsets, no lengths, and may contains zero offsets (to be
		 * skipped). There is an option in dat2nc utility program to generate
		 * the decomposition map in original form. The decomposition variables
		 * stored the map in original form are named "Dx.raw_nreqs" (number of
		 * offsets) and "Dx.raw_offsets" (offsets). If variable "Dx.raw_nreqs"
		 * presents in the decomposition NetCDF file, which means the original
		 * PIO decomposition was included, the ADIOS blob driver will reads the
		 * PIO decomposition map from the variables. Otherwise, this functions
		 * will converted the offset-length pairs back into the original map.
		 * See README file for more details.
		 */
		/* obtain varid of request variable Dx.raw_nreqs */
		sprintf (name, "D%d.raw_nreqs", id + 1);
		err = nc_inq_varid (ncid, name, &varid);
		if (err == NC_ENOTVAR) {
			has_raw_decom = 0;
		} else {
			CHECK_ERR
			has_raw_decom = 1;
		}

		if (has_raw_decom) {
			/* read all numbers of requests */
			all_raw_nreqs = (int *)malloc (decomp_nprocs * sizeof (int));
			err			  = nc_get_var_int (ncid, varid, all_raw_nreqs);
			CHECK_ERR

			/* calculate start index in Dx.offsets for this process */
			start = 0;
			for (i = 0; i < proc_start; i++) start += all_raw_nreqs[i];

			/* calculate number of requests for this process */
			count = 0;
			for (; i < proc_start + proc_count; i++) count += all_raw_nreqs[i];
			decom->raw_nreqs[id] = count;
			free (all_raw_nreqs);

			if (cfg->verbose)
				printf ("D%d rank %d: proc_start=%d proc_count=%d start%zd count=%zd\n", id + 1,
						rank, proc_start, proc_count, start, count);

			/* read starting offsets of requests into disps[] */
			decom->raw_offsets[id] =
				(MPI_Offset *)malloc (decom->raw_nreqs[id] * sizeof (MPI_Offset));
			sprintf (name, "D%d.raw_offsets", id + 1);
			err = nc_inq_varid (ncid, name, &varid);
			CHECK_ERR
			err = nc_get_vara_longlong (ncid, varid, &start, &count, decom->raw_offsets[id]);
			CHECK_ERR
		} else { /* Generate (simulated) raw decomposition map */
			/* Count number of offsets before merge */
			decom->raw_nreqs[id] = 0;
			for (i = 0; i < decom->contig_nreqs[id]; i++) {
				decom->raw_nreqs[id] += decom->blocklens[id][i];
			}

			decom->raw_offsets[id] =
				(MPI_Offset *)calloc (decom->raw_nreqs[id], sizeof (MPI_Offset));

			for (i = 0, j = 0; i < decom->contig_nreqs[id]; i++)
				for (k = decom->disps[id][i]; k < (decom->disps[id][i] + decom->blocklens[id][i]);
					 k++)
					decom->raw_offsets[id][j++] = k + 1;
		}

		if (cfg->verbose) {
			int min_blocklen = decom->blocklens[id][0];
			int max_blocklen = decom->blocklens[id][0];
			for (i = 1; i < decom->contig_nreqs[id]; i++) {
				max_blocklen = MAX (decom->blocklens[id][i], max_blocklen);
				min_blocklen = MIN (decom->blocklens[id][i], min_blocklen);
			}
			printf ("D%d rank %d nreqs=%d contig nreqs=%4d max_blocklen=%d min_blocklen=%d\n",
					id + 1, rank, nreqs, decom->contig_nreqs[id], max_blocklen, min_blocklen);
		}
	}

	err = nc_close (ncid);
	CHECK_ERR

err_out:
	if (err < 0) {
		for (id = 0; id < decom->num_decomp; id++) {
			decom->contig_nreqs[id] = 0;
			if (decom->disps[id] != NULL) free (decom->disps[id]);
			if (decom->blocklens[id] != NULL) free (decom->blocklens[id]);
		}
	}

	return err;
}
