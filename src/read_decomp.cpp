/*********************************************************************
 *
 * Copyright (C) 2021, Northwestern University
 * See COPYRIGHT notice in top-level directory.
 *
 * This program is part of the E3SM I/O benchmark.
 *
 *********************************************************************/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#include <mpi.h>

#include <e3sm_io.h>
#include <e3sm_io_err.h>
#include <e3sm_io_driver.hpp>

struct off_len {
    int off;
    int len;
};

/*----< compare() >---------------------------------------------------------*/
/* This subroutine is used in qsort() */
static int compare (const void *p1, const void *p2) {
    int i = ((struct off_len *)p1)->off;
    int j = ((struct off_len *)p2)->off;
    if (i > j) return (1);
    if (i < j) return (-1);
    return 0;
}

/*----< read_io_decomp() >-------------------------------------------------*/
/* Read I/O decomposition file, cfg->decomp_path. The contents of the file
 * are shown below, an example from 866x72_16p.nc
 *
 *   % ncdump -h f_case_866x72_16p.nc
 *   netcdf f_case_866x72_16p.nc {
 *   // file format: CDF-1
 *   dimensions:
 *       num_decomp = 3 ;
 *       decomp_nprocs = 16 ;
 *       D1.total_nreqs = 47 ;
 *       D2.total_nreqs = 407 ;
 *       D3.total_nreqs = 29788 ;
 *   variables:
 *       int D1.nreqs(decomp_nprocs) ;
 *           D1.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D1.offsets(D1.total_nreqs) ;
 *           D1.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D1.lengths(D1.total_nreqs) ;
 *           D1.lengths:description = "Lengths of noncontiguous requests" ;
 *           D1.lengths:max = 36 ;
 *           D1.lengths:min = 9 ;
 *       int D2.nreqs(decomp_nprocs) ;
 *           D2.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D2.offsets(D2.total_nreqs) ;
 *           D2.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D2.lengths(D2.total_nreqs) ;
 *           D2.lengths:description = "Lengths of noncontiguous requests" ;
 *           D2.lengths:max = 4 ;
 *           D2.lengths:min = 1 ;
 *       int D3.nreqs(decomp_nprocs) ;
 *           D3.nreqs:description = "Number of noncontiguous requests per process" ;
 *       int D3.offsets(D3.total_nreqs) ;
 *           D3.offsets:description = "Flattened starting indices of noncontiguous requests" ;
 *       int D3.lengths(D3.total_nreqs) ;
 *           D3.lengths:description = "Lengths of noncontiguous requests" ;
 *           D3.lengths:max = 4 ;
 *           D3.lengths:min = 1 ;
 *
 *   // global attributes:
 *       :command_line = "./dat2nc -o f_case_866x72_16p.nc -1
 * datasets/piodecomp16tasks16io01dims_ioid_514.dat -2
 * datasets/piodecomp16tasks16io01dims_ioid_516.dat -3
 * datasets/piodecomp16tasks16io02dims_ioid_548.dat " ; :D1.ndims = 1 ; :D1.dims = 866 ;
 *       :D1.max_nreqs = 4 ;
 *       :D1.min_nreqs = 2 ;
 *       :D2.ndims = 1 ;
 *       :D2.dims = 866 ;
 *       :D2.max_nreqs = 39 ;
 *       :D2.min_nreqs = 13 ;
 *       :D3.ndims = 2 ;
 *       :D3.dims = 72 , 866 ;
 *       :D3.max_nreqs = 2808 ;
 *       :D3.min_nreqs = 936 ;
 *   }
 *
 * Arguments:
 *   cfg->decomp_path: (IN) input file name, a NetCDF file containing the data
 *                     decomposition generated by PIO library from an E3SM run.
 *   decom->num_decomp (OUT) number of decompositions
 *   decom->ndims:     (OUT) number of decomposition dimensions
 *   decom->dims:      (OUT) global array dimension lengths of decompositions
 *   decom->contig_nreqs: (OUT) number of noncontiguous requests assigned to
 *                     this process. May be zero.
 *   decom->disps:     (OUT) starting offsets of individual requests (sorted)
 *                     Memory space will be allocated in this subroutine
 *                     and must be freed by the caller. Any pair of
 *                     disps[][i] and blocklens[][i] is within the size of
 *                     the least significant dimension.
 *   decom->blocklens: (OUT) lengths of individual requests
 *                     Memory space will be allocated in this subroutine
 *                     and must be freed by the caller.
 */

int read_decomp (e3sm_io_config *cfg, e3sm_io_decom *decom) {
    char name[128];
    int err, rank, nprocs, ncid, varid, proc_start, proc_count;
    int i, j, k, nreqs, *all_nreqs, *all_raw_nreqs, dimids[3], id;
    int has_raw_decom;
    size_t num, decomp_nprocs;
    MPI_Offset mpi_num, mpi_decomp_nprocs, start, count;
    MPI_Info info = MPI_INFO_NULL;
    e3sm_io_config decom_cfg;
    e3sm_io_driver *driver = NULL;
    int dims_int[4];
    int *raw_offsets_int = NULL;

    MPI_Comm_rank (cfg->io_comm, &rank);
    MPI_Comm_size (cfg->io_comm, &nprocs);

    // Set up config for read driver
    decom_cfg.io_comm        = MPI_COMM_WORLD;
    decom_cfg.info           = MPI_INFO_NULL;
    decom_cfg.num_iotasks    = nprocs;
    decom_cfg.num_subfiles   = 0;
    decom_cfg.out_path[0]    = '\0';
    decom_cfg.in_path[0]     = '\0';
    decom_cfg.decomp_path[0] = '\0';
    decom_cfg.hx             = -1;
    decom_cfg.wr             = 0;
    decom_cfg.rd             = 0;
    decom_cfg.nvars          = 0;
    decom_cfg.strategy       = undef_io;
    decom_cfg.api            = undef_api;
    decom_cfg.chunksize      = 0;
    decom_cfg.filter         = none;
    decom_cfg.verbose        = 0;
    decom_cfg.keep_outfile   = 0;
    decom_cfg.profiling      = 0;
    decom_cfg.two_buf        = 0;
    decom_cfg.non_contig_buf = 0;
    decom_cfg.io_stride      = 1;
    decom_cfg.sub_comm       = MPI_COMM_NULL;
    decom_cfg.rank           = rank;
    decom->num_decomp        = 0;

    // Set up driver
    driver = e3sm_io_get_driver (cfg->decomp_path, &decom_cfg);
    CHECK_PTR (driver)

    /* set MPI-IO hints: decomposition variables are usually small and enabling
     * collective buffering read can be expensive. Doing independent reads is
     * often much faster. An example is when using Lustre on Cori at NERSC.
     */
    MPI_Info_create (&info);
    MPI_Info_set (info, "romio_cb_read", "disable");
    MPI_Info_set (info, "romio_no_coll_rw", "false");

    /* open input file that contains I/O decomposition information */
    err = driver->open (cfg->decomp_path, cfg->io_comm, info, &ncid);
    CHECK_ERR

    MPI_Info_free (&info);

    /* number of decompositions stored in file */
    err = driver->inq_dim (ncid, "num_decomp", &dimids[0]);
    CHECK_ERR
    err = driver->inq_dimlen (ncid, dimids[0], &mpi_num);
    CHECK_ERR
    num = (size_t)mpi_num;
    decom->num_decomp = (int)num;

    /* number of processes used when the decomposition was produced */
    err = driver->inq_dim (ncid, "decomp_nprocs", &dimids[0]);
    CHECK_ERR
    err = driver->inq_dimlen (ncid, dimids[0], &mpi_decomp_nprocs);
    CHECK_ERR
    decomp_nprocs = (size_t)mpi_decomp_nprocs;

    /* decomp_nprocs is the number of processes used to generate the E3SM data
     * decomposition. nprocs is the number of processes running this benchmark.
     * This benchmark allows nprocs to be different from decomp_nprocs. When
     * nprocs is less than decomp_nprocs, some of nprocs processes will carry
     * out the requests for other decomp_nprocs processes. The requests
     * responsible by this process starts from proc_start with the number
     * proc_count. When nprocs is bigger than decomp_nprocs, then processes
     * with rank ID >= decomp_nprocs will have no write request and MUST
     * participate the collective I/O subroutines.
     */
    proc_count = decomp_nprocs / nprocs;
    proc_start = rank * proc_count;
    if (rank < (int)decomp_nprocs % nprocs) {
        proc_start += rank;
        proc_count++;
    } else
        proc_start += decomp_nprocs % nprocs;
    /* proc_count is the number of decomposition processes this process is
     * responsible to carry out their requests. proc_start is the starting
     * rank ID of the decomposition process.
     */

    /* id: D1, D2, ... D6, indicates different decompositions */
    for (id = 0; id < decom->num_decomp; id++) {
        decom->contig_nreqs[id] = 0;
        decom->disps[id]        = NULL;
        decom->blocklens[id]    = NULL;
        decom->raw_offsets[id]  = NULL;

        /* total number of noncontiguous requests of all processes */
        sprintf (name, "D%d.total_nreqs", id + 1);
        err = driver->inq_dim (ncid, name, &dimids[1]);
        CHECK_ERR

        /* ndims: number of decomposition dimensions, not variable dimensions
         * In E3SM, decomposition is along the lowest dimensions of 2D, 3D,
         * or 4D variables.
         */
        sprintf (name, "D%d.dims", id + 1);
        /* obtain the number of dimensions of this decomposition */
        err = driver->inq_att (ncid, NC_GLOBAL, name, &mpi_num);
        CHECK_ERR
        num = (size_t)mpi_num;
        decom->ndims[id] = (int)mpi_num;
        /* obtain the dimension lengths of this decomposition */
        err = driver->get_att (ncid, NC_GLOBAL, name, dims_int);
        CHECK_ERR
        for (i=0; i<decom->ndims[id]; i++)
            decom->dims[id][i] = (MPI_Offset)dims_int[i];

        if (cfg->fill_mode && cfg->strategy == canonical) {
            /* obtain varid of request variable Dx.nreqs. Note Dx.nreqs
             * includes the missing elements to be filled if there is any
             * missing elements and fill mode is enabled.
             */
            sprintf (name, "D%d.nreqs", id + 1);
            err = driver->inq_varid (ncid, name, &varid);
            CHECK_ERR
        }
        else {
            /* obtain varid of request variable Dx.fill_starts, the starting
             * index in offsets[] and lengths[] for elements to be filled with
             * fill value. Note use Dx.fill_starts as the number of write
             * requests, so writes stop at this index, without filling the
             * missing elements.
             */
            sprintf (name, "D%d.fill_starts", id + 1);
            err = driver->inq_varid (ncid, name, &varid);
            CHECK_ERR
        }

        /* read all processes's numbers of requests */
        all_nreqs = (int *)malloc (decomp_nprocs * sizeof (int));
        err = driver->get_vara (ncid, varid, MPI_INT, NULL, NULL, all_nreqs, coll);
        CHECK_ERR

        /* calculate start index in Dx.offsets for this process */
        start = 0;
        for (i=0; i<proc_start; i++) start += all_nreqs[i];

        /* calculate number of requests for this process */
        count = 0;
        for (; i < proc_start + proc_count; i++) count += all_nreqs[i];
        nreqs = count;
        free (all_nreqs);

        if (cfg->verbose)
            printf ("D%d rank %d: proc_start=%d proc_count=%d start=%lld count=%lld\n",
                    id + 1, rank, proc_start, proc_count, start, count);

        /* read starting offsets of requests into disps[] */
        decom->disps[id] = (int *)malloc (nreqs * sizeof (int));
        sprintf (name, "D%d.offsets", id + 1);
        err = driver->inq_varid (ncid, name, &varid);
        CHECK_ERR
        err = driver->get_vara (ncid, varid, MPI_INT, &start, &count, decom->disps[id], coll);
        CHECK_ERR

        /* read lengths of requests into blocklens[] */
        decom->blocklens[id] = (int *)malloc (nreqs * sizeof (int));
        sprintf (name, "D%d.lengths", id + 1);
        err = driver->inq_varid (ncid, name, &varid);
        CHECK_ERR
        err = driver->get_vara (ncid, varid, MPI_INT, &start, &count, decom->blocklens[id], coll);
        CHECK_ERR

        decom->contig_nreqs[id] = nreqs;

        if (cfg->api == adios) {
            /* ADIOS blob I/O requires the decomposition map in the original
             * form, i.e. all offsets, no lengths, and may contains zero
             * offsets (to be skipped). There is an option in dat2nc utility
             * program to generate the decomposition map in original form. The
             * decomposition variables stored the map in original form are
             * named "Dx.raw_nreqs" (number of offsets) and "Dx.raw_offsets"
             * (offsets). If variable "Dx.raw_nreqs" presents in the
             * decomposition NetCDF file, which means the original PIO
             * decomposition was included, the ADIOS blob driver will reads the
             * PIO decomposition map from the variables. Otherwise, this
             * functions will converted the offset-length pairs back into the
             * original map.  See README file for more details.
             */
            /* obtain varid of request variable Dx.raw_nreqs */
            sprintf (name, "D%d.raw_nreqs", id + 1);
            err = driver->inq_varid (ncid, name, &varid);
            has_raw_decom = (err == 0) ? 1 :  0;

            if (has_raw_decom) {
                /* read all numbers of requests */
                all_raw_nreqs = (int *)malloc (decomp_nprocs * sizeof (int));
                err = driver->get_vara (ncid, varid, MPI_INT, NULL, NULL, all_raw_nreqs, coll);
                CHECK_ERR

                /* calculate start index in Dx.offsets for this process */
                start = 0;
                for (i = 0; i < proc_start; i++) start += all_raw_nreqs[i];

                /* calculate number of requests for this process */
                count = 0;
                for (; i < proc_start + proc_count; i++) count += all_raw_nreqs[i];
                decom->raw_nreqs[id] = count;
                free (all_raw_nreqs);

                if (cfg->verbose)
                    printf ("D%d rank %d: proc_start=%d proc_count=%d start%lld count=%lld\n", id + 1,
                            rank, proc_start, proc_count, start, count);

                /* read starting offsets of requests into disps[] */
                decom->raw_offsets[id] =
                    (MPI_Offset *)malloc (decom->raw_nreqs[id] * sizeof (MPI_Offset));
                raw_offsets_int = (int *)malloc (decom->raw_nreqs[id] * sizeof (int));
                sprintf (name, "D%d.raw_offsets", id + 1);
                err = driver->inq_varid (ncid, name, &varid);
                CHECK_ERR
                err = driver->get_vara (ncid, varid, MPI_INT, &start, &count, raw_offsets_int, coll);
                CHECK_ERR
                for (i = 0; i < decom->raw_nreqs[id]; i++)
                    decom->raw_offsets[id][i] = (MPI_Offset)raw_offsets_int[i];

                free (raw_offsets_int);
                raw_offsets_int = NULL;
            } else {
                /* Generate (simulated) raw decomposition map. The below
                 * implementation is not ideal, as it sorts the offsets into an
                 * increasing order, which no longer be the same as the
                 * original maps. Consider generating the raw_offsets variables
                 * in the decomposition map files when running utility program
                 * 'dat2decomp' with option -r.
                 */

                /* Must sort all disps[] of all responsible requests into an
                 * increasing order (this is to satisfy the MPI fileview or
                 * monotonically nondecreasing file offset requirement)
                 */
                struct off_len *myreqs;
                myreqs = (struct off_len *)malloc (nreqs * sizeof (struct off_len));
                for (i = 0; i < nreqs; i++) {
                    myreqs[i].off = decom->disps[id][i];
                    myreqs[i].len = decom->blocklens[id][i];
                }
                qsort ((void *)myreqs, nreqs, sizeof (struct off_len), compare);
                for (i = 0; i < nreqs; i++) {
                    decom->disps[id][i]     = myreqs[i].off;
                    decom->blocklens[id][i] = myreqs[i].len;
                }
                free (myreqs);

                /* coalesce offset-length pairs */
                j = 0;
                for (i = 1; i < nreqs; i++) {
                    if (decom->disps[id][i] % decom->dims[id][decom->ndims[id] - 1] == 0 ||
                        decom->disps[id][i] != decom->disps[id][j] + decom->blocklens[id][j]) {
                        /* break contiguity at dimension boundaries or noncontiguous */
                        j++;
                        if (j < i) {
                            decom->disps[id][j]     = decom->disps[id][i];
                            decom->blocklens[id][j] = decom->blocklens[id][i];
                        }
                    } else
                        decom->blocklens[id][j] += decom->blocklens[id][i];
                }
                /* update number of true noncontiguous requests */
                if (nreqs > 0) decom->contig_nreqs[id] = j + 1;

                /* Count number of offsets before merge */
                decom->raw_nreqs[id] = 0;
                for (i = 0; i < decom->contig_nreqs[id]; i++)
                    decom->raw_nreqs[id] += decom->blocklens[id][i];

                decom->raw_offsets[id] =
                    (MPI_Offset *)calloc (decom->raw_nreqs[id], sizeof (MPI_Offset));

                /* Warning: below assumes the offsets of decom->disps[id][*]
                 * have been sorted into an increasing order
                 */
                for (i = 0, j = 0; i < decom->contig_nreqs[id]; i++)
                    for (k = decom->disps[id][i]; k < (decom->disps[id][i] + decom->blocklens[id][i]);
                         k++)
                        decom->raw_offsets[id][j++] = k + 1;
            }
        }

        if (cfg->verbose) {
            int min_blocklen = decom->blocklens[id][0];
            int max_blocklen = decom->blocklens[id][0];
            for (i = 1; i < decom->contig_nreqs[id]; i++) {
                max_blocklen = MAX (decom->blocklens[id][i], max_blocklen);
                min_blocklen = MIN (decom->blocklens[id][i], min_blocklen);
            }
            printf ("D%d rank %d nreqs=%d contig nreqs=%4d max_blocklen=%d min_blocklen=%d\n",
                    id + 1, rank, nreqs, decom->contig_nreqs[id], max_blocklen, min_blocklen);
        }
    }

    err = driver->close (ncid);
    CHECK_ERR

err_out:
    if (err < 0) {
        for (id = 0; id < decom->num_decomp; id++) {
            decom->contig_nreqs[id] = 0;
            if (decom->disps[id] != NULL) free (decom->disps[id]);
            if (decom->blocklens[id] != NULL) free (decom->blocklens[id]);
        }
    }
    if (raw_offsets_int) { free (raw_offsets_int); }
    if (driver) { delete driver; }

    return err;
}

